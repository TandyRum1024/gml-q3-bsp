<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Pre BSP loading setup
// Whether to render level with texture mapping.
drawNoTexture = false;

// Whether to render the level as leaf by leaf or face by face.
// this applies for textured draw only
drawLeafBatch = true;

// Unpack base assets directory
BSPAssetsDir = -1; //"testdata/pak0.pk3";

// BSP directory
BSPMapDir = -1;

// Map vertex buffer
BSPMapVB = -1;

// Map leaf &amp; leaffaces &amp; faces data
BSPMapFaces = -1;
BSPMapLeafs = -1;
BSPMapLeafFaces = -1;

// Map loaded?
BSPMapLoaded = false;
BSPMustLoad = true;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Load base asset &amp; BSP
viewer_load();
/*
if (drawNoTexture)
{
    zbsp_reset_baseassets(-1);
    
    show_debug_message("Loading map");
    map = zbsp_load_map(BSPMapDir, -1, false, true);
    
    show_debug_message("Building mesh");
    if (drawLeafBatch)
    {
        zbsp_vb_build_leafs_notexture(map);
        BSPMapVB = map[? "vb-leafs"];
    }
    else
    {
        zbsp_vb_build_faces_notexture(map);
        BSPMapVB = map[? "vb-faces"];
    }
}
else
{
    if (BSPAssetsDir != -1)
    {
        show_debug_message("Loading assets");
        zbsp_reset_baseassets(BSPAssetsDir);
    }
    
    show_debug_message("Loading map");
    map = zbsp_load_map(BSPMapDir, -1, true, true);
    BSPMapVB = map[? "vb-faces"];
}

if (map[? "success"])
{
    BSPMapLoaded = true;
    BSPMapLeafs = map[? "leafs-data"];
    BSPMapFaces = map[? "faces-data"];
    BSPMapLeafFaces = map[? "leaffaces-data"];
    
    show_debug_message("Map loading done");
}
else
{
    BSPMapLoaded = false;
    show_debug_message("Map loading error");
}
*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Misc. initialization &amp; Lightmap texture sampler

// Initialize UI system
iui_init();

// Debug currnet leaf visualization
debugCurrentLeaf = false;

// Debug draw related
debugDrawBbox = false; // draw bbox info
debugDrawLvol = false; // draw lightvol info

// Current lightmap selected for debug UI
debugCurrentLightmap = 0;

// Show camera up / forward vector?
debugShowAxis = false;

// Show debug panel?
debugPanel = false;

// Interpolation on/off
debugTextureLerp = false;

// PVS related
pvsClusterCurrent = 0; // current visible cluster index. recalculate PVS when this value is different from previous one
pvsClusterPrevious = 0;

pvsLeafsVisible = ds_list_create();
pvsLeafsCulled = 0;
pvsLeafCurrent = 0;

pvsFacesVisible = ds_list_create();

// list to store whether if we have already drawn the face
mapFacesDrawn = -1;
for (var i=0; i&lt;map[? "faces-num"]; i++)
{
    mapFacesDrawn[i] = false;
}

// Shader related
shaderLevelLightmap = shader_get_sampler_index(shd_level, "uLightmap");
currentLeafTintT = 0;

// time
t = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Camera init

// Mouse related
mouseSensitivity = 0.3;
mouseLock = false;

// Begin 3D
z3d_init();
display_reset(8, false);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Free memories
d3d_end();
zbsp_free_map(map);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update camera &amp; debug key input
var _scrw = window_get_width(), _scrh = window_get_height();

if (keyboard_check_pressed(ord('1')))
    debugDrawBbox = !debugDrawBbox;
    
if (keyboard_check_pressed(ord('2')))
    debugDrawLvol = !debugDrawLvol;
    
if (keyboard_check_pressed(ord('E')))
    debugPanel = !debugPanel;

if (keyboard_check_pressed(ord('R')))
    debugCurrentLeaf = !debugCurrentLeaf;
    
if (keyboard_check_pressed(ord('T')))
    debugShowAxis = !debugShowAxis;

if (keyboard_check_pressed(ord('I')))
    debugTextureLerp = !debugTextureLerp;
    
if (keyboard_check_pressed(ord('L')))
{
    mouseLock = !mouseLock;
    window_mouse_set(_scrw * 0.5, _scrh * 0.5);
}

if (BSPMapLoaded)
{
    if (mouseLock)
    {
        var _dx = window_mouse_get_x() - (_scrw * 0.5);
        var _dy = window_mouse_get_y() - (_scrh * 0.5);
        camRotH += _dx * mouseSensitivity;
        camRotV += _dy * mouseSensitivity;
        camTilt += _dx * mouseSensitivity * 0.2;
        window_mouse_set(_scrw * 0.5, _scrh * 0.5);
        
        z3d_update_vectors();
        
        // move camera
        var _inputfwd = keyboard_check(ord('W')) - keyboard_check(ord('S'));
        var _inputside = keyboard_check(ord('D')) - keyboard_check(ord('A'));
        if (_inputfwd != 0 || _inputside != 0)
        {
            var _wishdirx = camFwdX * _inputfwd - dsin(camRotH) * _inputside;
            var _wishdiry = camFwdY * _inputfwd + dcos(camRotH) * _inputside;
            var _wishdirz = camFwdZ * _inputfwd;
            
            z3d_accelerate(0.25, 6, _wishdirx, _wishdiry, _wishdirz);
        }
        
        camTilt += _inputside * 0.5;
    }
    else
    {
        z3d_update_vectors();
    }
    
    camX += camVX;
    camY += camVY;
    camZ += camVZ;
    camTilt = lerp(camTilt, 0, 0.08);
    camVX *= 0.95;
    camVY *= 0.95;
    camVZ *= 0.95;
}

iui_update_io();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update PVS &amp; Cull invisible leaf
if (BSPMapLoaded)
{
    // Get current leaf index
    pvsLeafCurrent = zbsp_get_leaf_idx(map, camX, camY, camZ);
    
    // fetch visible cluster index
    pvsClusterPrevious = pvsClusterCurrent;
    pvsClusterCurrent = BSPMapLeafs[# eBSP_LEAF.VISCLUSTER, pvsLeafCurrent];
    
    /// Calculate PVS if we're in different visible cluster from previous frame
    if (pvsClusterPrevious != pvsClusterCurrent)
    {
        show_debug_message("CALC PVS");
        
        pvsLeafsCulled = zbsp_get_visible_leafs(map, pvsLeafsVisible, pvsClusterCurrent);
        
        // clear out visible faces
        for (var i=0; i&lt;ds_list_size(pvsFacesVisible); i++)
        {
            var _faceidx = pvsFacesVisible[| i];
            mapFacesDrawn[@ _faceidx] = false;
        }
        
        ds_list_clear(pvsFacesVisible);
        
        for (var l=0; l&lt;ds_list_size(pvsLeafsVisible); l++)
        {
            var _currentleaf = pvsLeafsVisible[| l];
            var _lfidx = BSPMapLeafs[# eBSP_LEAF.LEAFFACE_IDX, _currentleaf];
            var _lfnum = BSPMapLeafs[# eBSP_LEAF.LEAFFACE_NUM, _currentleaf];
            
            for (var i=0; i&lt;_lfnum; i++)
            {
                var _faceidx = BSPMapLeafFaces[| _lfidx + i];
                if (!mapFacesDrawn[@ _faceidx])
                {
                    ds_list_add(pvsFacesVisible, _faceidx);
                    mapFacesDrawn[@ _faceidx] = true;
                }
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="76">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Load BSP
d3d_end();
d3d_set_projection_ortho(0, 0, room_width, room_height, 0);
display_reset(0, false);

texture_set_interpolation(false);

if (BSPMustLoad)
{
    viewer_reload();
    BSPAssetsDir = -1;
    BSPMustLoad = false;
}

texture_set_interpolation(true);

display_reset(8, false);
d3d_start();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw UI
t++;

var _scrw = window_get_width(), _scrh = window_get_height();
var _tophei = 160;
var _topmarginy = 35;

draw_set_font(fntMain16);
iui_begin();

if (!BSPMapLoaded)
{
    var _cx = _scrw * 0.5, _cy = _scrh * 0.5;
    draw_clear(iuDark);
    draw_sprite_ext(sprShrug, 0, _cx, _cy, 1, 1, 0, c_white, 1);
    draw_sprite_ext(sprShrug, 1, _cx, _cy - (sin(t * 0.05) * 0.5 + 0.5) * 16, 1, 1, sin(t * 0.025) * 2, c_white, 1);
    
    iui_align_push(1, 1);
    iui_label_shadow(_cx, _cy + 140, "Darn!", iuPiss, 0, 1, c_black);
    iui_label_shadow(_cx, _cy + 180, "Looks like you didn't load any map or something went wrong...#Press &lt;E&gt; to show debug menu and load the map!", iuCream, 0, 1, c_black);
    iui_align_pop();
}

if (debugPanel)
{
    iui_rect(0, 0, _scrw, _tophei, iuHellaDark);
    
    if (BSPMapLoaded)
        ui_tabidx = iui_tab(0, 0, 80, 30, pack("HELLO", "MAP", "PVS", "LMAP", "TEX"), ui_tabidx, 2);
    else
        ui_tabidx = iui_tab(0, 0, 80, 30, pack("HELLO"), ui_tabidx, 2);
    
    switch (ui_tabidx)
    {
        default:
        case 0:
            iui_align_push(1, 0);
            iui_label_shadow(_scrw * 0.5, _topmarginy, "BSP MAP VIEWER v1", iuCream, 0, 1, c_black);
            iui_label_shadow(_scrw * 0.5, _topmarginy + 20, "&lt;R&gt; : visualize current leaf#&lt;T&gt; : show axis info | &lt;I&gt; : Toggle lightmap filter#&lt;1&gt; : show leaf bbox | &lt;2&gt; : show lightvolume", iuCream, 0, 1, c_black);
            iui_align_pop();
            iui_align_push(2, 2);
            iui_label_shadow(_scrw, _tophei, "MMXIX ZIK", iuPiss, 0, 1, c_black);
            iui_align_pop();
            
            var _mustload = false;
            if (iui_button(10, _topmarginy + 20, 150, 32, "LOAD MAP"))
            {
                BSPMapDir = get_open_filename_ext("Quake 3 BSP maps|*.bsp|Quake 3 BSP zip/pk3 maps|*.zip;*.pk3", "", "", "Time to open a map file...");
                BSPMustLoad = true;
                
                camX = 0;
                camY = 0;
                camZ = 0;
            }
            
            if (iui_button(10, _topmarginy + 60, 150, 32, "LOAD ASSETS"))
            {
                BSPAssetsDir = get_open_filename_ext("Quake 3 assets|*.pk3", "", "", "Time to open a assets file...");
                BSPMustLoad = true;
            }
            break;
            
        case 1:
            iui_label_shadow(10, _topmarginy, "FILENAME : " + map[? "meta-filename"], iuCream, 0, 1, c_black);
            iui_label_shadow(10, _topmarginy + 20, "FILETYPE : " + map[? "meta-filetype"], iuCream, 0, 1, c_black);
            iui_label_shadow(10, _topmarginy + 40, "MAP NAME : " + map[? "meta-map-name"], iuCream, 0, 1, c_black);
            iui_label_shadow(10, _topmarginy + 60, "SUCCESS : " + string(map[? "success"]) + "#ERROR : " + map[? "error"], iuCream, 0, 1, c_black);
            break;
            
        case 2:
            iui_label_shadow(10, _topmarginy, "LEAF : " + string(ds_list_size(pvsLeafsVisible)), iuCream, 0, 1, c_black);
            iui_label_shadow(10, _topmarginy + 20, "LEAF CULLED : " + string(pvsLeafsCulled), iuCream, 0, 1, c_black);
            iui_label_shadow(10, _topmarginy + 40, "CURRENT CLUSTER : " + string(pvsClusterCurrent), iuCream, 0, 1, c_black);
            break;
    
        case 3:
            if (keyboard_check_pressed(vk_right))
            {
                debugCurrentLightmap = (debugCurrentLightmap + 1) % map[? "lightmaps-num"];
            }
            if (keyboard_check_pressed(vk_left))
            {
                debugCurrentLightmap = (debugCurrentLightmap + map[? "lightmaps-num"] - 1) % map[? "lightmaps-num"];
            }
        
            var _cx = _scrw * 0.5, _cy = _scrh * 0.5;
            iui_rect(0, _tophei, _scrw, _scrh - _tophei, iuHellaDark);
            //draw_surface_stretched(map[? "res-lightatlas-surf"], _cx - 300, _cy - 300, 600, 600);
            draw_sprite_stretched(map[? "res-lightatlas-spr"], 0, _cx - 300, _cy - 300, 600, 600);
            
            var _lightmaps = map[? "lightmaps-data"];
            var _lightmapspr = map[? "lightmaps-sprites"];
            var _lx1 = _lightmaps[# 1, debugCurrentLightmap] * 600;
            var _ly1 = _lightmaps[# 2, debugCurrentLightmap] * 600;
            var _lx2 = _lightmaps[# 3, debugCurrentLightmap] * 600;
            var _ly2 = _lightmaps[# 4, debugCurrentLightmap] * 600;
            
            iui_rect_pos(_cx - 300 + _lx1, _cy - 300 + _ly1, _cx - 300 + _lx2, _cy - 300 + _ly2, c_red, 0.5);
            //draw_sprite(_lightmapspr[| debugCurrentLightmap], 0, _cx - 300 + _lx1, _cy - 300 + _ly1);
            
            iui_align_push(1, 2);
            iui_label_shadow(_cx, _scrh - 10, "(LEFT/RIGHT ARROW TO CYCLE LIGHTMAP)#LIGHTMAP : " + string(debugCurrentLightmap), c_yellow, 0, 1, c_black);
            iui_align_pop();
            break;
            
        case 4:
            var _cx = _scrw * 0.5, _cy = _scrh * 0.5;
            iui_rect(0, _tophei, _scrw, _scrh - _tophei, iuHellaDark);
            
            var _textures = map[? "textures-sprites"];
            var _drawx = 0;
            var _drawy = _tophei;
            var _maxh = 0;
            
            for (var i=0; i&lt;ds_list_size(_textures); i++)
            {
                var _spr = _textures[| i];
                var _sprw = sprite_get_width(_spr), _sprh = sprite_get_height(_spr);
                var _sprratio = 64 / _sprw;
                
                draw_sprite_stretched(_spr, 0, _drawx, _drawy, _sprw * _sprratio, _sprh * _sprratio);
                _drawx += 64;
                _maxh = max(_maxh, _sprh * _sprratio);
                
                if (_drawx &gt; _scrw)
                {
                    _drawy += _maxh + 2;
                    _drawx = 0;
                    _maxh = 0;
                }
            }
            break;
    }
}

draw_set_font(fntMain16);
iui_align_push(2, 2);
if (mouseLock)
{
    var _wid = string_width("MOUSE LOCKED"), _hei = string_height("MOUSE LOCKED");
    iui_rect_pos(_scrw - _wid, _scrh - _hei, _scrw, _scrh, $FF00FF, 1);
    iui_label_shadow(_scrw, _scrh, "MOUSE LOCKED", c_white, 0, 1, c_black);
}
else
{
    var _wid = string_width("MOUSE UNLOCKED"), _hei = string_height("MOUSE UNLOCKED");
    iui_rect_pos(_scrw - _wid, _scrh - _hei, _scrw, _scrh, $FF00FF, 1);
    iui_label_shadow(_scrw, _scrh, "MOUSE UNLOCKED", c_white, 0, 1, c_black);
}
iui_align_pop();

iui_end();

if (debugShowAxis)
{
    var _amp = 64;
    draw_line_color(_scrw * 0.5, _scrh * 0.5, _scrw * 0.5 + camFwdY * _amp, _scrh * 0.5 + camFwdZ * _amp, c_red, c_red);
    draw_line_color(_scrw * 0.5, _scrh * 0.5, _scrw * 0.5 + camUpY * _amp, _scrh * 0.5 + camUpZ * _amp, c_blue, c_blue);
}

iui_align_push(2, 0);
var _str = "FPS : " + string(fps_real) + "#&lt;L&gt; : enable mouselook#&lt;E&gt; : toggle debug menu";

var _wid = string_width(_str), _hei = string_height(_str);
iui_rect_pos(_scrw - _wid, 0, _scrw, _hei, $FF00FF, 1);
iui_label_shadow(_scrw, 0, _str, c_white, 0, 1, c_black);
iui_align_pop();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set camera
d3d_set_projection_ext(camX, camY, camZ, camX + camFwdX, camY + camFwdY, camZ + camFwdZ, camUpX, camUpY, camUpZ, 90, window_get_width() / window_get_height(), 1, 16000);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw vertex buffers
if (BSPMapLoaded)
{
    currentLeafTintT++;
    
    // Draw level
    texture_set_repeat(true);
    texture_set_interpolation(debugTextureLerp);
        
    if (!drawNoTexture)
    {
        var _textures = map[? "textures-list"];
        
        shader_set(shd_level);
        
        // Set lightmap texture for shader
        texture_set_stage(shaderLevelLightmap, map[? "res-lightatlas-tex"]);
        
        // Reset tint
        var _uTint = shader_get_uniform(shd_level, "uTint");
        shader_set_uniform_f(_uTint, 1, 1, 1);
        
        // Draw all visible faces
        for (var i=0; i&lt;ds_list_size(pvsFacesVisible); i++)
        {
            var _faceidx = pvsFacesVisible[| i];
            var _texidx = BSPMapFaces[# eBSP_FACE.TEXTURE, _faceidx];
            vertex_submit(BSPMapVB[| _faceidx], pr_trianglelist, _textures[| _texidx]);
        }
        
        // And draw current leaf (with clown vomit-like rainbow colour) if needed
        if (debugCurrentLeaf)
        {
            var _rainbow = make_colour_hsv(currentLeafTintT * 2, 232, 255);
            shader_set_uniform_f(_uTint, (_rainbow &amp; $FF) / 255, ((_rainbow &amp; $FF00) &gt;&gt; 8) / 255, ((_rainbow &amp; $FF0000) &gt;&gt; 16) / 255);
            
            var _currentleaf = pvsLeafCurrent;
            var _lfidx = BSPMapLeafs[# eBSP_LEAF.LEAFFACE_IDX, _currentleaf];
            var _lfnum = BSPMapLeafs[# eBSP_LEAF.LEAFFACE_NUM, _currentleaf];
            
            for (var j=0; j&lt;_lfnum; j++)
            {
                var _faceidx = BSPMapLeafFaces[| _lfidx + j];
                
                var _texidx = BSPMapFaces[# eBSP_FACE.TEXTURE, _faceidx];
                var _vb = BSPMapVB[| _faceidx];
                
                vertex_submit(_vb, pr_trianglelist, _textures[| _texidx]);
            }
        }
        shader_reset();
    }
    else
    {
        shader_set(shd_level_notex);
        
        // Set lightmap texture for shader
        var _uTint = shader_get_uniform(shd_level_notex, "uTint");
        
        if (drawLeafBatch)
        {
            // Set lightmap texture for shader
            shader_set_uniform_f(_uTint, 1, 1, 1);
            
            // Draw all visible leafs
            for (var i=0; i&lt;ds_list_size(pvsLeafsVisible); i++)
            {   
                var _currentleaf = pvsLeafsVisible[| i];
                var _vb = BSPMapVB[| _currentleaf];
                vertex_submit(_vb, pr_trianglelist, map[? "res-lightatlas-tex"]);
            }
            
            // And draw current leaf (with clown vomit-like rainbow colour) if needed
            if (debugCurrentLeaf)
            {
                var _vb = BSPMapVB[| pvsLeafCurrent];
                var _rainbow = make_colour_hsv(currentLeafTintT * 2, 232, 255);
                shader_set_uniform_f(_uTint, (_rainbow &amp; $FF) / 255, ((_rainbow &amp; $FF00) &gt;&gt; 8) / 255, ((_rainbow &amp; $FF0000) &gt;&gt; 16) / 255);
                vertex_submit(_vb, pr_trianglelist, map[? "res-lightatlas-tex"]);
            }
        }
        else
        {
            shader_set_uniform_f(_uTint, 1, 1, 1);
        
            for (var i=0; i&lt;ds_list_size(pvsFacesVisible); i++)
            {
                var _faceidx = pvsFacesVisible[| i];
                
                var _texidx = BSPMapFaces[# eBSP_FACE.TEXTURE, _faceidx];
                var _vb = BSPMapVB[| _faceidx];
                
                vertex_submit(_vb, pr_trianglelist, map[? "res-lightatlas-tex"]);
            }
            
            // And draw current leaf (with clown vomit-like rainbow colour) if needed
            if (debugCurrentLeaf)
            {
                var _rainbow = make_colour_hsv(currentLeafTintT * 2, 232, 255);
                shader_set_uniform_f(_uTint, (_rainbow &amp; $FF) / 255, ((_rainbow &amp; $FF00) &gt;&gt; 8) / 255, ((_rainbow &amp; $FF0000) &gt;&gt; 16) / 255);
                
                var _currentleaf = pvsLeafCurrent;
                var _lfidx = BSPMapLeafs[# eBSP_LEAF.LEAFFACE_IDX, _currentleaf];
                var _lfnum = BSPMapLeafs[# eBSP_LEAF.LEAFFACE_NUM, _currentleaf];
                
                for (var j=0; j&lt;_lfnum; j++)
                {
                    var _faceidx = BSPMapLeafFaces[| _lfidx + j];
                    
                    var _texidx = BSPMapFaces[# eBSP_FACE.TEXTURE, _faceidx];
                    var _vb = BSPMapVB[| _faceidx];
                    
                    vertex_submit(_vb, pr_trianglelist, map[? "res-lightatlas-tex"]);
                }
            }
        }
        
        shader_reset();
    }
    
    texture_set_interpolation(true);
    texture_set_repeat(false);
    
    // Draw debug stuff
    if (debugDrawBbox)
        vertex_submit(map[? "vb-debug-bbox"], pr_linelist, -1);
    
    if (debugDrawLvol)
        vertex_submit(map[? "vb-debug-lightvol"], pr_trianglelist, -1);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
