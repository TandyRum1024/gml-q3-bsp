<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Init stuff (Loading happens in the STEP event; Not HERE!)
time = 0;

draw_set_font(fntMain16);

v3d_init();
q3_init();
loadingShown = false;
loadingReady = false;
mouseLock = true;
ignoreMouse = false;

//GREETINGZ
greetCtr = 1; //room_speed * 1.3;


// NOTE 2018 : Nice enum name lol
enum KOK
{
    WINEBLACK = $1C1C25,
    PISS = $00DDFF,
    WHITE = $D8EAF7,
    CREAM = $D0FDFF,
    BRM = $555370,
    MINT = $A1FF1E,
    GRAY = $6D6F7C,
    RED = $5E47E5,
    SLATE = $3F3336,
    LSLATE = $685E60,
    ASH = $212223,
}

// BSP related
mapToLoad = get_open_filename_ext("Quake 3 BSP filez|*.bsp", "", program_directory, "Choose a .BSP file to load!");
if (mapToLoad == "")
{
    show_message("!!Please select the BSP file!!");
    game_end();
    exit;
}

Q3MAP = -1;
LMAPS = -1;
numLMAPS = -1;
VERTS = -1;
FACES = -1;
LFACES = -1;
LEAVES = -1;
MVERTS = -1;
PLANES = -1;
VISDATA = -1;
NODES = -1;
VBUFF = -1;
cLEAF = -1;
vboCHUNK = 0;
bitFACE = 0;
visFACE = -1;
pCLUSTER = -1;

// NOTE : I could've refactored this using my ImNotGUI but I'm too lazy for this, I'm working on the new version anyway.
vui_init();

gINFO = vui_add_gui(8, 8, 420, 256, 0);
gLMAPDEBUG = vui_add_gui(16, room_height-213, room_width-32, 193, 0);
gFPS_L = vui_add_label(gINFO, 16, 34, 1, 1.2, "FPS : 0", KOK.WHITE, -1);
gCULL_L = vui_add_label(gINFO, 16, 54, 1, 1.2, "BACKFACE CULLING - YES", KOK.MINT, -1);
gFILTER_L = vui_add_label(gINFO, 16, 74, 1, 1.2, "INTERPOLATION - YES", KOK.MINT, -1);
gLEAF_L = vui_add_label(gINFO, 16, 94, 1, 1.2, "", KOK.WHITE, -1);

// NOTE : Translated those stuff into English; Uncomment at your own risk (?)
// gINFO_L = vui_add_label(gINFO, 16, 154, 0.9, 1.1, "WASD, SPACE, 마우스로 조작#U 키로 뒷면 그리기 켜기/ 끄기#I 키로 선형 보간 켜기/ 끄기#L 키로 라이트맵 보기&amp; 숨기기", KOK.WHITE, -1);
gINFO_L = vui_add_label(gINFO, 16, 140, 0.9, 1.1, "[WASD &amp; SPACE] to MOVE &amp; [Mouse] to LOOK.#[ESC] to lock / unlock MOUSE!#[U] To toggle Backface Culling#[I] To toggle Texture Interpolation#[L] to show / hide LightMap", KOK.WHITE, -1);
gLMAP_LABEL = vui_add_label(gLMAPDEBUG, 10, 10, 0, 0, "LIGHTMAP DUMP", KOK.WHITE, -1);

CULL = true;
INTERPOLATE = true;
texture_set_interpolation(true);

/*
    0 - Mesh &amp; polygon
*/
DRAWMODE = 0;

/*var gLMAP_TP, gLMAP_L;
var DesiredSize = (512 / min(array_length_1d(LMAPS), 3)) - 32;

for (var i=0;i&lt;array_length_1d(LMAPS);i++)
{
    gLMAP_TP = vui_add_texPanel(gLMAPDEBUG, (DesiredSize + 16) * (i % 3) + 16, (DesiredSize + 16) * (i div 3) + 16, DesiredSize, DesiredSize, surface_get_texture(LMAPS[@ i]), -1);
    gLMAP_L = vui_add_label(gLMAPDEBUG, 1, 1, 0.7, 1.4, "LIGHTMAP", c_white, gLMAP_TP);
}*/

// STARTUP SOUND!
var JETTDL = audio_play_sound(sndTatap, 0, 0);
audio_sound_gain(JETTDL, 0.8, 0);
audio_master_gain( 0.5 );
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// LOAD BSP and UPDATE THING
if (!loadingReady)
{
    if (loadingShown)
    {
        //LOAD BSP
        Q3MAP = load_q3bsp( mapToLoad );
        
        // Get map properties
        LMAPS = Q3MAP[@ 0];
        numLMAPS = Q3MAP[@ 1];
        show_debug_message(string(numLMAPS)+" LIGHTMAPS"); // how many lightmaps did we got here?
        VERTS = Q3MAP[@ 2];
        FACES = Q3MAP[@ 3];
        LFACES = Q3MAP[@ 4];
        LEAVES = Q3MAP[@ 5];
        MVERTS = Q3MAP[@ 6];
        PLANES = Q3MAP[@ 7];
        VISDATA = Q3MAP[@ 8];
        NODES = Q3MAP[@ 9];
        VBUFF = Q3MAP[@ 10];
        
        cLEAF = -1;
        visLEAF = ds_list_create();
        //Vertex buffers?
        vboCHUNK = 0;
        
        //Face visible &amp; bitset &amp; stuff
        bitFACE = 0;
        visFACE = ds_list_create();
        pCLUSTER = -1;
        
        /* Create LIGHTMAP debug */
        gLMAP_TP = vui_add_texPanel(gLMAPDEBUG, 10, 55, room_width-52, 128, surface_get_texture(LMAPS), -1);
        gLMAPDEBUG.visible = false;
        surface_save(LMAPS,"Lmap.png");
        
        
        
        loadingReady = true;
    }
}
else
{
    // Loaded indication sound
    // It used to play "WELCOME TO QUAKE LOL" voiceline but because of copyright issues,
    // I've changed it to my custom notify sound.
    if (greetCtr &gt;= 0 &amp;&amp; --greetCtr == 0)
    {
        var LOL = audio_play_sound(sndLoaded, 0, 0);
        audio_sound_gain(LOL, 0.8, 0);
    }
    
    //process player input
    var FORWARD = (keyboard_check(ord('W')) - keyboard_check(ord('S')));
    var RIGHT = (keyboard_check(ord('D')) - keyboard_check(ord('A')));
    
    P_VEL[@ 0] += FORWARD*CROT[@ 0] + RIGHT*CROT[@ 4];
    P_VEL[@ 1] += FORWARD*CROT[@ 1] + RIGHT*CROT[@ 5];
    P_VEL[@ 2] += FORWARD*CROT[@ 2] + RIGHT*CROT[@ 6];
    
    /*
        (NOTE 2019 : Looks like this was used to swizzle around the coordinates system, I'm fixing &amp; leaving this here)
        
        My coords system :
        X = Forward
        Y = Right
        Z = Up
        
        QUAKE :
        X = Right
        Y = Towards you
        Z = Down
        
        QUAKE -&gt; My system
        Y -&gt; -X
        X -&gt; Y
    */
    P_VEL[@ 0] += keyboard_check(vk_up)-keyboard_check(vk_down);
    P_VEL[@ 1] += keyboard_check(vk_right)-keyboard_check(vk_left);
    P_VEL[@ 2] += keyboard_check(vk_space);
    
    //INTEGRATE
    C_POS[@ 0] += P_VEL[@ 0];
    C_POS[@ 1] += P_VEL[@ 1];
    C_POS[@ 2] += P_VEL[@ 2];
    
    //DAMP
    P_VEL[@ 0] *= 0.85;
    P_VEL[@ 1] *= 0.85;
    P_VEL[@ 2] *= 0.85;
    
    //M_LOOK
    var sens = 0.22;
    var H_LOOK = 0, V_LOOK = 0;
    
    if (mouseLock)
    {
        H_LOOK = window_get_width()/2 - window_mouse_get_x();
        V_LOOK = window_get_height()/2 - window_mouse_get_y();
        
        if (ignoreMouse)
        {
            H_LOOK = 0;
            V_LOOK = 0;
            
            if (abs(window_mouse_get_x() - window_get_width()/2) &lt;= 4 &amp;&amp;
                abs(window_mouse_get_y() - window_get_height()/2) &lt;= 4)
                ignoreMouse = false;
        }
        
        window_mouse_set(window_get_width()/2,window_get_height()/2);
    }
    
    //TILT
    P_TILT += H_LOOK * 0.02;
    P_TILT += RIGHT * 0.7;
    P_TILT = lerp(P_TILT, 0, 0.03);
    
    //GOOD
    //C_ROT[@ 0] = P_TILT;
    C_ROT[@ 1] += V_LOOK*sens;
    C_ROT[@ 2] += H_LOOK*sens;
    
    //Update cam
    v3d_update_camera();
    
    /*
        CULL SOME LEAVES
    */
    /* FIND THE CURRENT LEAF */
    
    var IND = 0;
    
    while (IND &gt;= 0)
    {
        var nPLANE = NODES[@ IND, 0];
        var pDIST = PLANES[@ nPLANE, 3];
        
        var cDIST = dot_product_3d(PLANES[@ nPLANE, 0], PLANES[@ nPLANE, 1], PLANES[@ nPLANE, 2], C_POS[@ 0], C_POS[@ 1], C_POS[@ 2]) - pDIST;
        //show_debug_message("DIST : "+string(cDIST)+", IND : "+string(IND));
        if (cDIST &gt;= 0)
        {
            IND = NODES[@ IND, 1];
        }
        else
        {
            IND = NODES[@ IND, 2];
        }
    }
    
    cLEAF = (IND * -1) - 1;
    
    
    var cCLUSTER = LEAVES[@ cLEAF, 0];
    var VISTST, CULLED = 0;
    
    /* Iterate through all leaves and check PVS */
    if (cCLUSTER != pCLUSTER || pCLUSTER == -1)
    {
        pCLUSTER = cCLUSTER;
        ds_list_clear(visLEAF);
        for (var i=0;i&lt;array_height_2d(LEAVES);i++)
        {
            VISTST = q3_cluster_visible(cCLUSTER, LEAVES[@ i, 0], VISDATA[@ 2]);
            if (VISTST)
            {
                ds_list_add(visLEAF, i);
                LEAVES[@ i, 12] = true;
            }
            else
            {
                LEAVES[@ i, 12] = false;
                CULLED++;
            }
        }
        gLEAF_L.STR = string(CULLED)+" LEAF occluded";
        // gLEAF_L.STR = string(CULLED)+" 개의 LEAF가 가려짐";
    }
    
    //Update GUI
    if (keyboard_check_pressed(ord('U')))
    {
        if (CULL)
        {
            CULL = false;
            gCULL_L.STR = "BACKFACE CULLING - NOPE";
            gCULL_L.COL = KOK.RED;
            d3d_set_culling(false);
            
            var ASS = audio_play_sound(sndTap, 0, 0);
            audio_sound_gain(ASS, 0.6, 0);
        }
        else
        {
            CULL = true;
            gCULL_L.STR = "BACKFACE CULLING - YES";
            gCULL_L.COL = KOK.MINT;
            d3d_set_culling(true);
            
            var ASS = audio_play_sound(sndTap, 0, 0);
            audio_sound_gain(ASS, 0.6, 0);
        }
    }
    if (keyboard_check_pressed(ord('I')))
    {
        if (INTERPOLATE)
        {
            INTERPOLATE = false;
            gFILTER_L.STR = "INTERPOLATION - NOPE (PIXEL)";
            gFILTER_L.COL = KOK.RED;
        
            var ASS = audio_play_sound(sndTap, 0, 0);
            audio_sound_gain(ASS, 0.6, 0);
        }
        else
        {
            INTERPOLATE = true;
            gFILTER_L.STR = "INTERPOLATION - YES";
            gFILTER_L.COL = KOK.MINT;
            
            var ASS = audio_play_sound(sndTap, 0, 0);
            audio_sound_gain(ASS, 0.6, 0);
        }
    }
    if (keyboard_check_pressed(ord('L')))
    {
        gLMAPDEBUG.visible = !gLMAPDEBUG.visible;
        
        var ASS = audio_play_sound(sndTap, 0, 0);
        audio_sound_gain(ASS, 0.6, 0);
    }
    
    // mouse lock?
    if (keyboard_check_pressed(vk_escape))
    {
        mouseLock = !mouseLock;
        window_mouse_set(window_get_width()/2,window_get_height()/2);
    
        ignoreMouse = true;
    }
    
    time+=0.5;
    gINFO_L.COL = make_colour_hsv(time%255, 230, 245);
    gFPS_L.STR = "FPS : "+string(fps_real);
    vui_update();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="72">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>v3d_update_projection();

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!loadingReady)
{
    texture_set_interpolation(false);
    draw_set_halign(1);
    draw_set_valign(1);
    draw_set_font(fntStyle16);
    
    var CX = window_get_width() / 2;
    var CY = window_get_height() / 2;
    
    draw_clear(KOK.ASH);
    
    draw_rectangle_colour(0, 0, CX * 2, 128, KOK.MINT, KOK.MINT, KOK.MINT, KOK.MINT, false);
    draw_rectangle_colour(0, CY * 2 - 128, CX * 2, CY * 2, KOK.MINT, KOK.MINT, KOK.MINT, KOK.MINT, false);
    
    // Draw loading screen first before loading
    draw_text_transformed_colour(CX, CY + 7, "LOADIN'", 7, 7, 0, 0, 0, 0, 0, 1);
    draw_text_transformed_colour(CX, CY, "LOADIN'", 7, 7, 0, KOK.PISS, KOK.PISS, KOK.PISS, KOK.PISS, 1);
    
    draw_text_transformed_colour(CX, CY + 82, "Might take a moment...", 2, 2, 0, 0, 0, 0, 0, 1);
    draw_text_transformed_colour(CX, CY + 80, "Might take a moment...", 2, 2, 0, KOK.CREAM, KOK.CREAM, KOK.CREAM, KOK.CREAM, 1);
    
    //draw_sprite(sLoading, 0, 0, 0);
    loadingShown = true;
    
    draw_set_halign(0);
    draw_set_valign(0);
    texture_set_interpolation(true);
}
else
{
    vui_draw();
    
    texture_set_interpolation(false);
    if (!mouseLock)
    {
        draw_set_halign(1);
        draw_set_valign(1);
        draw_set_font(fntStyle16);
        
        var CX = window_get_width() / 2;
        var CY = window_get_height() / 2;
        
        var textCol = KOK.RED;
        if ((time &gt;&gt; 5) &amp; 1)
            textCol = KOK.MINT;
        
        draw_text_transformed_colour(CX, CY + sin(time * 0.01) * 10, "MOUSE UNLOCKED!", 4, 4, 0, textCol, textCol, textCol, textCol, 1);
        
        draw_set_font(fntMain16);
        
        var rainbow = make_colour_hsv(time%255, 255, 255);
        draw_text_transformed_colour(CX, CY + 80, "-=[ Press [ESC] AGAIN TO LOCK ]=-", 2, 2, sin(time * 0.05) * 2, rainbow, rainbow, rainbow, rainbow, sin(time * 0.15));
        
        draw_set_halign(0);
        draw_set_valign(0);
    }
    texture_set_interpolation(true);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw BSP
if (loadingReady)
{
    //DRAW MAP THING
    var fINDEX, fNUM, lFACE, FACETYPE, sMVERT, nMVERT, sVERT, iLMAP, vCUR, X, Y, Z, U, V, nX, nY, nZ
    var i, VB;
    
    //Iterate through leaves n' draw
    shader_set(shd_map);
    
        /* Setup textures */
        var light = shader_get_sampler_index(shd_map, "vLightMap");
        texture_set_interpolation_ext(light, INTERPOLATE);
        texture_set_stage(light, surface_get_texture(LMAPS));
        
        for (var l=0;l&lt;ds_list_size(visLEAF);l++)
        {
            i = visLEAF[| l];
            VB = VBUFF[| i];
            
            // submit vertex
            vertex_submit(VB, pr_trianglelist, -1);
            
            // Leaf AABB debug visualization
            /*var minBOX_X = LEAVES[@ i, 2];
            var minBOX_Y = LEAVES[@ i, 3];
            var minBOX_Z = LEAVES[@ i, 4];
            
            var maxBOX_X = LEAVES[@ i, 5];
            var maxBOX_Y = LEAVES[@ i, 6];
            var maxBOX_Z = LEAVES[@ i, 7];
            
            //draw AABB i guess
            d3d_primitive_begin(pr_linelist);
                d3d_vertex_colour(maxBOX_X, minBOX_Y, minBOX_Z, c_lime, 1);
                d3d_vertex_colour(minBOX_X, minBOX_Y, minBOX_Z, c_lime, 1);
                
                d3d_vertex_colour(minBOX_X, maxBOX_Y, minBOX_Z, c_lime, 1);
                d3d_vertex_colour(minBOX_X, minBOX_Y, minBOX_Z, c_lime, 1);
                
                d3d_vertex_colour(minBOX_X, minBOX_Y, maxBOX_Z, c_lime, 1);
                d3d_vertex_colour(minBOX_X, minBOX_Y, minBOX_Z, c_lime, 1);
                
                d3d_vertex_colour(minBOX_X, maxBOX_Y, maxBOX_Z, c_lime, 1);
                d3d_vertex_colour(maxBOX_X, maxBOX_Y, maxBOX_Z, c_lime, 1);
                
                d3d_vertex_colour(maxBOX_X, minBOX_Y, maxBOX_Z, c_lime, 1);
                d3d_vertex_colour(maxBOX_X, maxBOX_Y, maxBOX_Z, c_lime, 1);
                
                d3d_vertex_colour(maxBOX_X, maxBOX_Y, minBOX_Z, c_lime, 1);
                d3d_vertex_colour(maxBOX_X, maxBOX_Y, maxBOX_Z, c_lime, 1);
            d3d_primitive_end();
            */
        }
    shader_reset();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
