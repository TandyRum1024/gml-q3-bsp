<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Init stuff (Loading happens in the STEP event; Not HERE!)
time = 0;

draw_set_font(Hack_SeoulNamsan);
// NOTE 2018 : Why did I made my own 3D scripts and reinvent the whole wheel ew
v3d_init();
q3_init();
loadingShown = false;
loadingReady = false;
mouseLock = true;
ignoreMouse = false;

//GREETINGZ
greetCtr = room_speed * 1.3;
BGM = audio_play_sound(Q1_INTRO, 0, 0);
audio_sound_gain(BGM, 0.3, 0);


// NOTE 2018 : Nice enum name lol
enum KOK
{
    WINEBLACK = $1C1C25,
    PISS = $00DDFF,
    WHITE = $D8EAF7,
    CREAM = $D0FDFF,
    THICCBROWN = $555370,
    MINT = $A1FF1E,
    GRAY = $6D6F7C,
    RED = $5E47E5,
    SLATE = $3F3336,
    LSLATE = $685E60,
    ASH = $212223,
}

// BSP related
// Change "asylum.bsp" to another map (See : Included Files for maps I've prepared)
// EX : mapToLoad = "threestory.bsp";
// mapToLoad = "asylum.bsp";
mapToLoad = get_open_filename_ext("Quake 3 BSP filez|*.bsp", "", program_directory, "Choose a .BSP file to load!");
if (mapToLoad == "")
{
    show_message("!!Please select the BSP file!!");
    game_end();
    exit;
}

Q3MAP = -1;
LMAPS = -1;
numLMAPS = -1;
VERTS = -1;
FACES = -1;
LFACES = -1;
LEAVES = -1;
MVERTS = -1;
PLANES = -1;
VISDATA = -1;
NODES = -1;
VBUFF = -1;
cLEAF = -1;
vboCHUNK = 0;
bitFACE = 0;
visFACE = -1;
pCLUSTER = -1;

// NOTE 2018 : I could've refactored this using my ImNotGUI but I'm too lazy for this
vui_init();

gINFO = vui_add_gui(8, 8, 420, 256, 0);
gLMAPDEBUG = vui_add_gui(16, room_height-213, room_width-32, 193, 0);
gFPS_L = vui_add_label(gINFO, 16, 34, 1, 1.2, "FPS : 0", KOK.WHITE, -1);
gCULL_L = vui_add_label(gINFO, 16, 54, 1, 1.2, "BACKFACE CULLING - YES", KOK.MINT, -1);
gFILTER_L = vui_add_label(gINFO, 16, 74, 1, 1.2, "INTERPOLATION - YES", KOK.MINT, -1);
gLEAF_L = vui_add_label(gINFO, 16, 94, 1, 1.2, "", KOK.WHITE, -1);

// NOTE 2018 : Translated those stuff into English; Uncomment at your own risk (?)
// gINFO_L = vui_add_label(gINFO, 16, 154, 0.9, 1.1, "WASD, SPACE, 마우스로 조작#U 키로 뒷면 그리기 켜기/ 끄기#I 키로 선형 보간 켜기/ 끄기#L 키로 라이트맵 보기&amp; 숨기기", KOK.WHITE, -1);
gINFO_L = vui_add_label(gINFO, 16, 140, 0.9, 1.1, "[WASD &amp; SPACE] to MOVE &amp; [Mouse] to LOOK.#[ESC] to lock / unlock MOUSE!#[U] To toggle Backface Culling#[I] To toggle Texture Interpolation#[L] to show / hide LightMap", KOK.WHITE, -1);
gLMAP_LABEL = vui_add_label(gLMAPDEBUG, 10, 10, 0, 0, "LIGHTMAP DUMP", KOK.WHITE, -1);

CULL = true;
INTERPOLATE = true;
texture_set_interpolation(true);

/*
    0 - Mesh &amp; polygon
*/
DRAWMODE = 0;

/*var gLMAP_TP, gLMAP_L;
var DesiredSize = (512 / min(array_length_1d(LMAPS), 3)) - 32;

for (var i=0;i&lt;array_length_1d(LMAPS);i++)
{
    gLMAP_TP = vui_add_texPanel(gLMAPDEBUG, (DesiredSize + 16) * (i % 3) + 16, (DesiredSize + 16) * (i div 3) + 16, DesiredSize, DesiredSize, surface_get_texture(LMAPS[@ i]), -1);
    gLMAP_L = vui_add_label(gLMAPDEBUG, 1, 1, 0.7, 1.4, "LIGHTMAP", c_white, gLMAP_TP);
}*/

//EEAUGH!
var JETTDL = audio_play_sound(EEAUGH, 0, 0);
audio_sound_gain(JETTDL, 0.8, 0);
audio_master_gain( 0.5 );
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// LOAD BSP and UPDATE THING
if (!loadingReady)
{
    if (loadingShown)
    {
        //LOAD BSP
        Q3MAP = load_q3bsp( mapToLoad );
        
        // Get map properties
        LMAPS = Q3MAP[@ 0];
        numLMAPS = Q3MAP[@ 1];
        show_debug_message(string(numLMAPS)+" LIGHTMAPS"); // how many lightmaps did we got here?
        VERTS = Q3MAP[@ 2];
        FACES = Q3MAP[@ 3];
        LFACES = Q3MAP[@ 4];
        LEAVES = Q3MAP[@ 5];
        MVERTS = Q3MAP[@ 6];
        PLANES = Q3MAP[@ 7];
        VISDATA = Q3MAP[@ 8];
        NODES = Q3MAP[@ 9];
        VBUFF = Q3MAP[@ 10];
        
        cLEAF = -1;
        visLEAF = ds_list_create();
        //Vertex buffers?
        vboCHUNK = 0;
        
        //Face visible &amp; bitset &amp; stuff
        bitFACE = 0;
        visFACE = ds_list_create();
        pCLUSTER = -1;
        
        // NOTE 2018 : This was suppossed to be some sort of Bitmask debug thing..
        // I dunno.
        /*var numCLUSTERS = VISDATA[@ 0];
        var byteCLUSTER = VISDATA[@ 1];
        var BITSET = VISDATA[@ 2];
        var cBIT,BITZ;
        var MASK = (255);
        
        for (var i=0;i&lt;numCLUSTERS;i++)
        {
            cBIT = (BITSET &amp; (MASK &lt;&lt; (i*8))) &gt;&gt; (i*8);
            BITZ = "";
            
            for (var j=byteCLUSTER*8-1;j&gt;=0;j--)
            {
                BITZ = BITZ + string( (cBIT &amp; (1 &lt;&lt; j)) &gt;&gt; j );
            }
            
            show_debug_message("BITSET "+ansi_char(65+i)+" : ("+string(string_length(BITZ))+")"+BITZ);
        }*/
        
        /* Create LIGHTMAP debug */
        gLMAP_TP = vui_add_texPanel(gLMAPDEBUG, 10, 55, room_width-52, 128, surface_get_texture(LMAPS), -1);
        gLMAPDEBUG.visible = false;
        surface_save(LMAPS,"Lmap.png");
        
        
        
        loadingReady = true;
    }
}
else
{
    //Greetz
    if (greetCtr &gt;= 0 &amp;&amp; --greetCtr == 0)
    {
        var LOL = audio_play_sound(WELCOME_LOL, 0, 0);
        audio_sound_gain(LOL, 0.8, 0);
    }
    
    //process player input
    var FORWARD = (keyboard_check(ord('W')) - keyboard_check(ord('S')));
    var RIGHT = (keyboard_check(ord('D')) - keyboard_check(ord('A')));
    
    P_VEL[@ 0] += FORWARD*CROT[@ 0] + RIGHT*CROT[@ 4];
    P_VEL[@ 1] += FORWARD*CROT[@ 1] + RIGHT*CROT[@ 5];
    P_VEL[@ 2] += FORWARD*CROT[@ 2] + RIGHT*CROT[@ 6];
    
    /*
        ME
        X = Forward
        Y = Right
        Z = Up
        
        QUAKE
        X = East (right)
        Y = South (At your body)
        Z = Down
        
        QUAKE -&gt; ME
        Y -&gt; -X
        X -&gt; Y
    */
    P_VEL[@ 0] += keyboard_check(vk_up)-keyboard_check(vk_down);
    P_VEL[@ 1] += keyboard_check(vk_right)-keyboard_check(vk_left);
    P_VEL[@ 2] += keyboard_check(vk_space);
    
    //INTEGRATE
    C_POS[@ 0] += P_VEL[@ 0];
    C_POS[@ 1] += P_VEL[@ 1];
    C_POS[@ 2] += P_VEL[@ 2];
    
    //DAMP
    P_VEL[@ 0] *= 0.85;
    P_VEL[@ 1] *= 0.85;
    P_VEL[@ 2] *= 0.85;
    
    //M_LOOK
    var sens = 0.22;
    var H_LOOK = 0, V_LOOK = 0;
    
    if (mouseLock)
    {
        H_LOOK = window_get_width()/2 - window_mouse_get_x();
        V_LOOK = window_get_height()/2 - window_mouse_get_y();
        
        if (ignoreMouse)
        {
            H_LOOK = 0;
            V_LOOK = 0;
            
            if (abs(window_mouse_get_x() - window_get_width()/2) &lt;= 4 &amp;&amp;
                abs(window_mouse_get_y() - window_get_height()/2) &lt;= 4)
                ignoreMouse = false;
        }
        
        window_mouse_set(window_get_width()/2,window_get_height()/2);
    }
    
    //TILT
    P_TILT += H_LOOK * 0.02;
    P_TILT += RIGHT * 0.7;
    P_TILT = lerp(P_TILT, 0, 0.03);
    
    //GOOD
    //C_ROT[@ 0] = P_TILT;
    C_ROT[@ 1] += V_LOOK*sens;
    C_ROT[@ 2] += H_LOOK*sens;
    
    //Update cam
    v3d_update_camera();
    
    /*
        CULL SOME LEAVES
    */
    /* FIND THE CURRENT LEAF */
    
    var IND = 0;
    
    while (IND &gt;= 0)
    {
        var nPLANE = NODES[@ IND, 0];
        var pDIST = PLANES[@ nPLANE, 3];
        
        var cDIST = dot_product_3d(PLANES[@ nPLANE, 0], PLANES[@ nPLANE, 1], PLANES[@ nPLANE, 2], C_POS[@ 0], C_POS[@ 1], C_POS[@ 2]) - pDIST;
        //show_debug_message("DIST : "+string(cDIST)+", IND : "+string(IND));
        if (cDIST &gt;= 0)
        {
            IND = NODES[@ IND, 1];
        }
        else
        {
            IND = NODES[@ IND, 2];
        }
    }
    
    cLEAF = (IND * -1) - 1;
    
    
    var cCLUSTER = LEAVES[@ cLEAF, 0];
    var VISTST, CULLED = 0;
    
    /* Iterate thru' Leaves and do shit */
    if (cCLUSTER != pCLUSTER || pCLUSTER == -1)
    {
        pCLUSTER = cCLUSTER;
        ds_list_clear(visLEAF);
        for (var i=0;i&lt;array_height_2d(LEAVES);i++)
        {
            VISTST = q3_cluster_visible(cCLUSTER, LEAVES[@ i, 0], VISDATA[@ 2]);
            if (VISTST)
            {
                ds_list_add(visLEAF, i);
                LEAVES[@ i, 12] = true;
            }
            else
            {
                LEAVES[@ i, 12] = false;
                CULLED++;
            }
        }
        gLEAF_L.STR = string(CULLED)+" LEAF occluded";
        // gLEAF_L.STR = string(CULLED)+" 개의 LEAF가 가려짐";
    }
    
    //Update GUI
    if (keyboard_check_pressed(ord('U')))
    {
        if (CULL)
        {
            CULL = false;
            gCULL_L.STR = "BACKFACE CULLING - NOPE";
            gCULL_L.COL = KOK.RED;
            d3d_set_culling(false);
            
            var ASS = audio_play_sound(choose(BOOM, OOF), 0, 0);
            audio_sound_gain(ASS, 0.6, 0);
        }
        else
        {
            CULL = true;
            gCULL_L.STR = "BACKFACE CULLING - YES";
            gCULL_L.COL = KOK.MINT;
            d3d_set_culling(true);
            
            var ASS = audio_play_sound(BUTT, 0, 0);
            audio_sound_gain(ASS, 0.6, 0);
        }
    }
    if (keyboard_check_pressed(ord('I')))
    {
        if (INTERPOLATE)
        {
            INTERPOLATE = false;
            gFILTER_L.STR = "INTERPOLATION - NOPE (PIXEL)";
            gFILTER_L.COL = KOK.RED;
            texture_set_interpolation(false);
        
            var ASS = audio_play_sound(choose(BOOM, OOF), 0, 0);
            audio_sound_gain(ASS, 0.6, 0);
        }
        else
        {
            INTERPOLATE = true;
            gFILTER_L.STR = "INTERPOLATION - YES";
            gFILTER_L.COL = KOK.MINT;
            texture_set_interpolation(true);
            
            var ASS = audio_play_sound(BUTT, 0, 0);
            audio_sound_gain(ASS, 0.6, 0);
        }
    }
    if (keyboard_check_pressed(ord('L')))
    {
        gLMAPDEBUG.visible = !gLMAPDEBUG.visible;
        var ASS = audio_play_sound(choose(BASH1, BASH2), 0, 0);
        audio_sound_gain(ASS, 0.6, 0);
    }
    
    // mouse lock?
    if (keyboard_check_pressed(vk_escape))
    {
        mouseLock = !mouseLock;
        window_mouse_set(window_get_width()/2,window_get_height()/2);
    
        ignoreMouse = true;
    }
    
    time+=0.5;
    gINFO_L.COL = make_colour_hsv(time%255, 230, 245);
    gFPS_L.STR = "FPS : "+string(fps_real);
    vui_update();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="72">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>v3d_update_projection();

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!loadingReady)
{
    // Draw loading screen first before loading
    draw_sprite(sLoading, 0, 0, 0);
    loadingShown = true;
}
else
{
    vui_draw();
    
    if (!mouseLock)
    {
        draw_set_halign(1);
        draw_set_valign(1);
        draw_set_font(ONELIGHTER);
        
        var CX = window_get_width() / 2;
        var CY = window_get_height() / 2;
        
        var textCol = KOK.RED;
        if ((time &gt;&gt; 5) &amp; 1)
            textCol = KOK.MINT;
        
        draw_text_colour(CX, CY + sin(time * 0.01) * 10, "MOUSE UNLOCKED!", textCol, textCol, textCol, textCol, 1);
        
        draw_set_font(Hack_SeoulNamsan);
        
        var rainbow = make_colour_hsv(time%255, 255, 255);
        draw_text_transformed_colour(CX, CY + 80, "-=[ Press [ESC] AGAIN TO LOCK ]=-", 2, 2, sin(time * 0.05) * 4, rainbow, rainbow, rainbow, rainbow, sin(time * 0.025));
        
        draw_set_halign(0);
        draw_set_valign(0);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw BSP
if (loadingReady)
{
    //DRAW MAP THING
    var fINDEX, fNUM, lFACE, FACETYPE, sMVERT, nMVERT, sVERT, iLMAP, vCUR, X, Y, Z, U, V, nX, nY, nZ
    var i, VB;
    
    // NOTE 2018 : Back then, I didn't knew how vertex buffers worked.
    // So I've done it some sorta inefficient way; But now I have known better, Here's
    // A better idea :
    // You could put those vertex infos into a *NORMAL* buffers, Not vertex buffers.
    // Then, when you draw the map, You basically put it into one vertex buffer, AKA one big batch!
    // Thus saving some draw calls &amp; juice out those sweet sweet FPS.
    
    //Iterate through leaves n' draw
    shader_set(shd_map);
    
        /* Setup textures */
        var light = shader_get_sampler_index(shd_map, "vLightMap");
        texture_set_stage(light, surface_get_texture(LMAPS));
    
        for (var l=0;l&lt;ds_list_size(visLEAF);l++)
        {
            i = visLEAF[| l];
            VB = VBUFF[| i];
            
            // submit vertex; Oh jeez this things really inefficient.
            // See above for better idea for implementing this.
            vertex_submit(VB, pr_trianglelist, -1);
            
            // Leaf debug.
            /*var minBOX_X = LEAVES[@ i, 2];
            var minBOX_Y = LEAVES[@ i, 3];
            var minBOX_Z = LEAVES[@ i, 4];
            
            var maxBOX_X = LEAVES[@ i, 5];
            var maxBOX_Y = LEAVES[@ i, 6];
            var maxBOX_Z = LEAVES[@ i, 7];
            
            //draw AABB i guess
            d3d_primitive_begin(pr_linelist);
                d3d_vertex_colour(maxBOX_X, minBOX_Y, minBOX_Z, c_lime, 1);
                d3d_vertex_colour(minBOX_X, minBOX_Y, minBOX_Z, c_lime, 1);
                
                d3d_vertex_colour(minBOX_X, maxBOX_Y, minBOX_Z, c_lime, 1);
                d3d_vertex_colour(minBOX_X, minBOX_Y, minBOX_Z, c_lime, 1);
                
                d3d_vertex_colour(minBOX_X, minBOX_Y, maxBOX_Z, c_lime, 1);
                d3d_vertex_colour(minBOX_X, minBOX_Y, minBOX_Z, c_lime, 1);
                
                d3d_vertex_colour(minBOX_X, maxBOX_Y, maxBOX_Z, c_lime, 1);
                d3d_vertex_colour(maxBOX_X, maxBOX_Y, maxBOX_Z, c_lime, 1);
                
                d3d_vertex_colour(maxBOX_X, minBOX_Y, maxBOX_Z, c_lime, 1);
                d3d_vertex_colour(maxBOX_X, maxBOX_Y, maxBOX_Z, c_lime, 1);
                
                d3d_vertex_colour(maxBOX_X, maxBOX_Y, minBOX_Z, c_lime, 1);
                d3d_vertex_colour(maxBOX_X, maxBOX_Y, maxBOX_Z, c_lime, 1);
            d3d_primitive_end();
            */
        }
    shader_reset();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
